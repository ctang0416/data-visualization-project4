import {
  require_react_dom
} from "./chunk-DF6XA7QC.js";
import {
  require_react
} from "./chunk-CLECMD5P.js";
import {
  __toESM
} from "./chunk-5CYG367S.js";

// node_modules/react-svg-tooltip/dist/react-svg-tooltip.es5.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function _AwaitValue(value) {
  this.wrapped = value;
}
function _AsyncGenerator(gen) {
  var front, back;
  function send(key, arg) {
    return new Promise(function(resolve, reject) {
      var request = {
        key,
        arg,
        resolve,
        reject,
        next: null
      };
      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }
  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function(arg2) {
        if (wrappedAwait) {
          resume("next", arg2);
          return;
        }
        settle(result.done ? "return" : "normal", arg2);
      }, function(err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }
  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value,
          done: true
        });
        break;
      case "throw":
        front.reject(value);
        break;
      default:
        front.resolve({
          value,
          done: false
        });
        break;
    }
    front = front.next;
    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }
  this._invoke = send;
  if (typeof gen.return !== "function") {
    this.return = void 0;
  }
}
if (typeof Symbol === "function" && Symbol.asyncIterator) {
  _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
    return this;
  };
}
_AsyncGenerator.prototype.next = function(arg) {
  return this._invoke("next", arg);
};
_AsyncGenerator.prototype.throw = function(arg) {
  return this._invoke("throw", arg);
};
_AsyncGenerator.prototype.return = function(arg) {
  return this._invoke("return", arg);
};
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
var svgPoint = function svgPoint2(svg, event) {
  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX;
    point.y = event.clientY;
    point = point.matrixTransform(svg.getScreenCTM().inverse());
    return [point.x, point.y];
  }
  var rect = svg.getBoundingClientRect();
  return [event.clientX - rect.left - svg.clientLeft, event.clientY - rect.top - svg.clientTop];
};
var TooltipComponent = function(_React$Component) {
  _inherits(TooltipComponent2, _React$Component);
  function TooltipComponent2() {
    var _this;
    _classCallCheck(this, TooltipComponent2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(TooltipComponent2).apply(this, arguments));
    _this.state = {
      type: "TooltipHidden"
    };
    _this.updateTooltip = function(evt) {
      if (_this.props) {
        var svg = _this.props.containerRef ? _this.props.containerRef.current : _this.safeMouseTrigger ? _this.safeMouseTrigger.ownerSVGElement : void 0;
        if (svg) {
          var mousePosition = svgPoint(svg, evt);
          _this.setState({
            type: "TooltipVisible",
            svgSvgElement: svg,
            x: mousePosition[0],
            y: mousePosition[1]
          });
        }
      }
    };
    _this.hideTooltip = function() {
      _this.setState({
        type: "TooltipHidden"
      });
    };
    return _this;
  }
  _createClass(TooltipComponent2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var mouseTrigger = this.props.triggerRef.current;
      if (mouseTrigger && mouseTrigger.addEventListener) {
        this.safeMouseTrigger = mouseTrigger;
        mouseTrigger.addEventListener("mouseover", this.updateTooltip);
        mouseTrigger.addEventListener("mousemove", this.updateTooltip);
        mouseTrigger.addEventListener("mouseleave", this.hideTooltip);
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (this.state.type === "TooltipHidden") {
        return (0, import_react.createElement)("g", null);
      } else {
        var x = this.state.x;
        var y = this.state.y;
        var tooltip = (0, import_react.createElement)("g", {
          className: "Tooltip",
          transform: "translate(".concat(x, ", ").concat(y, ")"),
          pointerEvents: "none"
        }, this.props.children instanceof Function ? this.props.children(x, y) : this.props.children);
        return (0, import_react_dom.createPortal)(tooltip, this.state.svgSvgElement);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.safeMouseTrigger && this.safeMouseTrigger.removeEventListener) {
        this.safeMouseTrigger.removeEventListener("mouseover", this.updateTooltip);
        this.safeMouseTrigger.removeEventListener("mousemove", this.updateTooltip);
        this.safeMouseTrigger.removeEventListener("mouseleave", this.hideTooltip);
      }
    }
  }]);
  return TooltipComponent2;
}(import_react.Component);
export {
  TooltipComponent as Tooltip,
  svgPoint
};
//# sourceMappingURL=react-svg-tooltip.js.map
